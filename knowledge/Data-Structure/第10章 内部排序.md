[TOC]

# 第10章 内部排序

## 10.1 概述
**排序**（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。

由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：<br/>
一类是**内部排序**，指的是待排序记录存放在计算机随机存储器中进行的排序过程；<br/>
另一类是**外部排序**，指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。

如果按排序过程中依据的不同原则对内部排序方法进行分类，大致可分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；

如果按内部排序过程中所需的工作量来区分，则可分为3类：<br/>
(1) 简单的排序方法，其时间复杂度为*O* (n^2^)；<br/>
(2) 先进的排序方法，其时间复杂度为*O* (nlogn)；<br/>
(3) 基数排序，其时间复杂度为*O* (d · n)。<br/>

有兴趣了解更多算法的读者可阅读D.E.克努特著《计算机程序设计技巧》（第三卷，排序和查找）。

通常，在排序的过程中需进行下列两种操作：<br/>
(1) 比较两个关键字的大小；<br/>
(2) 将计入从一个位置移动到另一个位置。

前一个操作对大多数排序方法来说都是必要的，而后一个操作可以通过改变记录的存储方式来避免。待排序的记录序列可有下列3种存储方式：<br/>
(1) 待排序的一组记录存放在地址连续的一组存储单元上。它类似于线性表的顺序存储结构，在序列中相邻的两个记录*R* ~j~ 和*R* ~j+1~（j=1,2,···，n-1），它们的存储位置也相邻。在这种存储方式中，记录之间的次序关系由其存储位置决定，则实现排序必须借助移动记录；<br/>
(2) 一组待排序记录存放在静态链表中，记录之间的次序关系由指针指示，则实现排序不需要移动记录，仅需修改指针即可；<br/>
(3) 待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向量中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。

在第二种存储方式下实现的排序又称（链）表排序，在第三种存储方式下实现的排序又称地址排序。

本章的讨论中，待排序的一组记录以第一种方式存储，为了讨论方便起见，设记录的关键字均为正数。在以后的讨论的大部分算法中，待排记录的数据类型设为：

```
#define MAXSIZE 20           // 一个用作示例的小顺序表的最大长度
typedef int KeyType;         // 定义关键字类型为整数类型
typedef struct {
    KeyType key;             // 关键字项
    InfoType otherinfo;      // 其他数据项
}RedType;                    // 记录类型
typedef struct {
    RedType r[MAXSIZE + 1];  // r[0]闲置或用作哨兵单元
    int length;              // 顺序表长度
}SqList;                     // 顺序表类型
```

## 10.2 插入排序

### 10.2.1 直接插入排序

**直接插入排序**（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好序的有序表中，从而得到一个新的/记录新增1的有序表。

例如，有待排序的一组记录的初始排列如下所示：<br/>
[49, 38, 65, 97, 76, 13, 27, ++49++, ···]  （10-4）

假设在排序过程中，前4个记录已按关键字递增的次序重新排列，构成一个含4个记录的有序序列：<br/>
[38, 49, 65, 97]  （10-5）

现要将（10-4）中的第5个（即关键字76）记录插入(10-5)序列，得到一个新的含5个记录的有序序列，首先在（10-5）的序列中查找确定76应插入的位置，然后进行插入。假设从右往左顺序查找，由于65 < 76 < 97，76应插入在65和97之间，从而得到一个新的有序序列：<br/>
[38, 49, 65, 76, 97]  （10-6）

（10-5）到（10-6）的过程为一趟直接插入排序。一般情况下，第i趟直接插入排序的操作为：在含有i-1个记录的有序子序列r[1..i-1]中插入一个记录r[i]后，变成含有i个记录的有序子序列r[1..i]；并且，和顺序查找类似，为了在查找插入位置的过程中避免数组下标出界，在r[0]处设置监视哨。在自i-1起往前搜索的过程中，可以同时后移记录。整个排序过程为进行n-1趟插入，即：先将序列中的第1个记录看成是一个有序的子序列，然后从第2个记录起逐个进行插入，直至整个序列变成按关键字递增有序序列为止。其算法如**算法10.1**所示：

```
  void InsertSort(SqList &L) {
      // 对顺序表L作直接插入排序
      for (i = 2; i <= L.length; ++i) {
          if(L.r[i].key < L.r[i-1].key) {
              L.r[0] = L.r[i];                   // 复制为哨兵
              L.r[i] = L.r[i - 1];
              for(j = i - 2; L.r[0].key < L.r[j].key; --j) {
                  L.r[j + 1] = L.r[j];           // 记录后移
              }
              L.r[j + 1] = L.r[0];               // 插入到正确位置
          }
      }
  }
```

以（10-4）中关键字为例，按照算法10.1进行直接插入排序的过程如下所示：<br/>
[初始关键字]：　　(49) 38 65 97 76 13 27 ++49++ <br/>
　　　 i = 2：(38) (38 49) 65 97 76 13 27 ++49++ <br/>
　　　 i = 3：(65) (38 49 65) 97 76 13 27 ++49++ <br/>
　　　 i = 4：(97) (38 49 65 97) 76 13 27 ++49++ <br/>
　　　 i = 5：(76) (38 49 65 76 97) 13 27 ++49++ <br/>
　　　 i = 6：(13) (13 38 49 65 76 97) 27 ++49++ <br/>
　　　 i = 7：(27) (13 27 38 49 65 76 97) ++49++ <br/>
　　　 i = 8：(++49++) (13 27 38 49 ++49++ 65 76 97) <br/>

